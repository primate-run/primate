import * as path from "path";
import { svelte2tsx } from "svelte2tsx";
import type * as ts from "typescript/lib/tsserverlibrary";

// tiny helpers (avoid internal TS APIs)
const normalize = (p: string) => p.replace(/\\/g, "/");
const resolveFrom = (containingFile: string, spec: string) =>
  normalize(path.isAbsolute(spec)
    ? spec
    : path.resolve(path.dirname(containingFile), spec));

function init(mods: { typescript: typeof import("typescript/lib/tsserverlibrary") }) {
  const ts = mods.typescript;

  function create(info: ts.server.PluginCreateInfo) {
    const log = (m: string) => info.project.projectService.logger.info(`[plsp] ${m}`);
    const host = info.languageServiceHost;

    log(`plugin loaded (cwd: ${info.project.getCurrentDirectory()})`);

    // 1) Treat .svelte as TSX
    const origGetScriptKind = host.getScriptKind?.bind(host);
    host.getScriptKind = (fileName: string) => {
      if (fileName.endsWith(".svelte")) return ts.ScriptKind.TSX;
      return origGetScriptKind ? origGetScriptKind(fileName) : ts.ScriptKind.Unknown;
    };

    // 2) Module resolution for "*.svelte"
    const origResolveLits = host.resolveModuleNameLiterals?.bind(host);
    if (origResolveLits) {
      host.resolveModuleNameLiterals = (
        moduleLiterals,
        containingFile,
        redirectedReference,
        options,
        containingSourceFile,
        reusedNames,
      ) => {
        const base = origResolveLits(
          moduleLiterals,
          containingFile,
          redirectedReference,
          options,
          containingSourceFile,
          reusedNames,
        );
        return base.map((res, i) => {
          if (res.resolvedModule) return res;
          const spec = moduleLiterals[i].text;
          if (spec.endsWith(".svelte")) {
            const resolvedFileName = resolveFrom(containingFile, spec);
            return {
              resolvedModule: {
                resolvedFileName,
                extension: ts.Extension.Tsx,
                isExternalLibraryImport: false,
              },
            };
          }
          return res;
        });
      };
    } else {
      const origResolveNames = host.resolveModuleNames?.bind(host);
      host.resolveModuleNames = (
        moduleNames,
        containingFile,
        reusedNames,
        redirectedReference,
        options,
        containingSourceFile,
      ) => {
        const base = origResolveNames
          ? origResolveNames(moduleNames, containingFile, reusedNames, redirectedReference, options, containingSourceFile)
          : new Array(moduleNames.length).fill(undefined);
        return moduleNames.map((spec, i) => {
          if (base[i]) return base[i];
          if (typeof spec === "string" && spec.endsWith(".svelte")) {
            const resolvedFileName = resolveFrom(containingFile, spec);
            const rm: ts.ResolvedModuleFull = {
              resolvedFileName,
              extension: ts.Extension.Tsx,
              isExternalLibraryImport: false,
            };
            return rm;
          }
          return base[i];
        });
      };
    }

    // 3) Serve transformed TSX snapshots for *.svelte (use editor buffer)
    const origGetScriptSnapshot = host.getScriptSnapshot.bind(host);
    const origGetScriptVersion = host.getScriptVersion.bind(host);
    const cache = new Map<string, { v: string; snap: ts.IScriptSnapshot }>();

    host.getScriptSnapshot = (filename: string) => {
      if (filename.endsWith(".svelte")) {
        const v = origGetScriptVersion(filename) || "0";
        const key = `${filename}::${v}`;
        const hit = cache.get(key);
        if (hit) return hit.snap;

        const src = origGetScriptSnapshot(filename);
        if (!src) return src;

        const text = src.getText(0, src.getLength());
        try {
          const { code } = svelte2tsx(text, {
            filename: path.basename(filename),
            isTsFile: true,
          });

          // Extract $$ComponentProps with proper brace counting
          const typeStart = code.indexOf("type $$ComponentProps =");
          let exportCode = "";

          if (typeStart !== -1) {
            const afterEquals = typeStart + "type $$ComponentProps =".length;
            let braceCount = 0;
            let inType = false;
            let endPos = afterEquals;

            for (let i = afterEquals; i < code.length; i++) {
              const char = code[i];
              if (char === "{") {
                braceCount++;
                inType = true;
              } else if (char === "}") {
                braceCount--;
              } else if (char === ";" && braceCount === 0 && inType) {
                endPos = i;
                break;
              }
            }

            const propsType = code.substring(afterEquals, endPos).trim();
            exportCode = `
              type Props = ${propsType};
              const component: (props: Props) => any = null as any;
              export default component;
            `;
            log(`Extracted props type: ${propsType}`);
          } else {
            log("Could not find $$ComponentProps in generated code");
            exportCode = `
              const component: (props: {}) => any = null as any;
              export default component;
            `;
          }

          const snap = ts.ScriptSnapshot.fromString(exportCode);
          cache.set(key, { v, snap });
          return snap;
        } catch (e: any) {
          log(`svelte2tsx error in ${filename}: ${e?.message ?? e}`);
          return ts.ScriptSnapshot.fromString("export {}");
        }
      }
      return origGetScriptSnapshot(filename);
    };

    return info.languageService;
  }

  return { create };
}

export = init;
